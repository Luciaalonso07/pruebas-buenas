Option Explicit

'========================================================================================
'   SINCRONIZADOR DE PLANTILLA -> EXCELS HIJOS (subcarpetas + recursivo)
'
'   OBJETIVO:
'   - Partiendo de una carpeta raíz (SINCRONIZADA con OneDrive/SharePoint),
'     recorre TODO el árbol de subcarpetas y sincroniza cada Excel "hijo" con la Plantilla.
'
'   QUÉ HACE AL SINCRONIZAR CADA HOJA (según CFG_SYNC):
'   - Alinea columnas: inserta columnas nuevas del template en el hijo cuando falten.
'   - (Opcional) Elimina columnas "extra" del hijo que no existan en el template.
'   - Evita que al RENOMBRAR cabeceras se borren los datos: si detecta renombre,
'     actualiza SOLO la cabecera y conserva datos.
'   - Limpia referencias externas tipo [Plantilla.xlsm] en fórmulas pegadas.
'
'   IMPORTANTE SHAREPOINT:
'   - VBA NO puede listar carpetas sobre URL web. Debes trabajar sobre la carpeta
'     sincronizada (OneDrive - EY) que "representa" SharePoint en el Explorador.
'
'========================================================================================


'=============================
'   AJUSTES PRINCIPALES
'=============================
Private Const CFG_SHEET_NAME As String = "CFG_SYNC"

' Extensiones que se procesan como "hijos"
Private Const PROCESS_XLSX As Boolean = True
Private Const PROCESS_XLSM As Boolean = True
Private Const PROCESS_XLSB As Boolean = True
Private Const PROCESS_XLS As Boolean = True

' Si True: borra columnas del hijo que NO existen en template (según claves de cabecera)
Private Const DELETE_EXTRA_COLUMNS As Boolean = True

' Si True: copia formatos de cabecera de plantilla al hijo
' OJO: en hojas con KEY_ROW (p.ej. procesos) NO se repinta para no "machacar" cabeceras
Private Const REFRESH_HEADER_FORMATS As Boolean = True

' Si True: limpia [Plantilla.xlsm] / ['C:\...\Plantilla.xlsm'] de fórmulas
Private Const FIX_EXTERNAL_REFS_WHOLE_SHEET As Boolean = True

' Si True: detecta renombres de cabeceras y actualiza SOLO cabecera conservando datos
Private Const HANDLE_HEADER_RENAMES As Boolean = True

' Carpeta que NO quieres recorrer (tu carpeta de plantilla)
' Ajusta el nombre EXACTO como aparece en el explorador
Private Const EXCLUDE_TEMPLATE_FOLDER_NAME As String = "00. Plantilla BIA"


'=============================
'   PUNTO DE ENTRADA
'=============================
Public Sub SYNC_RunSharePoint()

    Dim rootFolder As String
    rootFolder = GetRootFolder()

    If Len(rootFolder) = 0 Then
        MsgBox "No se pudo calcular la carpeta raíz.", vbExclamation
        Exit Sub
    End If

    If Dir(rootFolder, vbDirectory) = vbNullString Then
        MsgBox "La carpeta raíz no existe o no está disponible:" & vbCrLf & rootFolder, vbExclamation
        Exit Sub
    End If

    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Application.EnableEvents = False

    Dim oldCalc As XlCalculation
    oldCalc = Application.Calculation
    Application.Calculation = xlCalculationManual

    On Error GoTo CleanFail

    ' Recorre TODO el árbol bajo rootFolder
    SyncAllChildrenRecursive rootFolder

CleanExit:
    Application.CutCopyMode = False
    Application.Calculation = oldCalc
    Application.EnableEvents = True
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "SYNC terminado.", vbInformation
    Exit Sub

CleanFail:
    MsgBox "Error en SYNC: " & Err.Description, vbCritical
    Resume CleanExit
End Sub


'========================================================================================
'   1) RUTA RAÍZ (SHAREPOINT SINCRONIZADO)
'========================================================================================
Private Function GetRootFolder() As String
    ' RECOMENDADO: OneDrive corporativo
    ' Esta ruta NO debe llevar tu usuario fijo, así sirve para todo el equipo.

    Dim od As String
    od = Environ$("OneDriveCommercial") ' suele existir en OneDrive corporativo

    If Len(od) = 0 Then
        od = Environ$("OneDrive") ' fallback
    End If

    ' Ajusta el nombre EXACTO de la carpeta raíz sincronizada
    ' (la que en tu captura es "Banca March_EY - Proyecto Automatización BIA")
    GetRootFolder = od & "\Banca March_EY - Proyecto Automatización BIA"
End Function


'========================================================================================
'   2) RECORRIDO RECURSIVO DE CARPETAS (PROCESA TODOS LOS EXCEL)
'========================================================================================
Private Sub SyncAllChildrenRecursive(ByVal folderPath As String)
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")
    If Not fso.FolderExists(folderPath) Then Exit Sub

    Dim folder As Object: Set folder = fso.GetFolder(folderPath)

    ' 2.1) Procesar EXCELS en esta carpeta
    Dim f As Object
    For Each f In folder.Files
        If IsExcelFile(f.Name) Then
            ' evita temporales y evita abrir el propio libro de la macro
            If Left$(f.Name, 2) <> "~$" Then
                If LCase$(f.Name) <> LCase$(ThisWorkbook.Name) Then
                    SyncOneChildWorkbook f.Path
                End If
            End If
        End If
    Next f

    ' 2.2) Bajar a subcarpetas (menos la carpeta plantilla)
    Dim subf As Object
    For Each subf In folder.SubFolders
        If LCase$(subf.Name) <> LCase$(EXCLUDE_TEMPLATE_FOLDER_NAME) Then
            SyncAllChildrenRecursive subf.Path
        End If
    Next subf
End Sub

Private Function IsExcelFile(ByVal fileName As String) As Boolean
    Dim ext As String
    If InStrRev(fileName, ".") = 0 Then Exit Function
    ext = LCase$(Mid$(fileName, InStrRev(fileName, ".") + 1))

    IsExcelFile = _
        ((ext = "xlsx" And PROCESS_XLSX) Or _
         (ext = "xlsm" And PROCESS_XLSM) Or _
         (ext = "xlsb" And PROCESS_XLSB) Or _
         (ext = "xls" And PROCESS_XLS))
End Function


'========================================================================================
'   3) SINCRONIZAR 1 ARCHIVO HIJO
'========================================================================================
Private Sub SyncOneChildWorkbook(ByVal childFullPath As String)

    Dim wbChild As Workbook
    Set wbChild = Workbooks.Open(childFullPath, ReadOnly:=False)

    On Error GoTo SafeClose

    SyncWorkbookFromTemplate ThisWorkbook, wbChild

    wbChild.Close SaveChanges:=True
    Exit Sub

SafeClose:
    On Error Resume Next
    wbChild.Close SaveChanges:=False
End Sub


'========================================================================================
'   4) LEER CFG_SYNC Y SINCRONIZAR HOJAS
'========================================================================================
Private Sub SyncWorkbookFromTemplate(ByVal wbTemplate As Workbook, ByVal wbChild As Workbook)

    Dim wsCfg As Worksheet
    Set wsCfg = wbTemplate.Worksheets(CFG_SHEET_NAME)

    Dim lastRow As Long
    lastRow = wsCfg.Cells(wsCfg.Rows.Count, "A").End(xlUp).Row

    Dim r As Long
    For r = 2 To lastRow

        Dim activeFlag As String
        activeFlag = Trim$(CStr(wsCfg.Cells(r, "A").Value))

        If UCase$(activeFlag) = "Y" Then

            Dim templateSheetName As String
            templateSheetName = CStr(wsCfg.Cells(r, "B").Value)

            Dim childSheetName As String
            childSheetName = CStr(wsCfg.Cells(r, "C").Value)
            If Len(Trim$(childSheetName)) = 0 Then childSheetName = templateSheetName

            Dim headerTop As Long, headerBottom As Long, dataStart As Long
            headerTop = CLng(wsCfg.Cells(r, "D").Value)
            headerBottom = CLng(wsCfg.Cells(r, "E").Value)
            dataStart = CLng(wsCfg.Cells(r, "F").Value)

            Dim firstCol As Long, lastCol As Long
            firstCol = CLng(wsCfg.Cells(r, "G").Value)  ' 0 = AUTO
            lastCol = CLng(wsCfg.Cells(r, "H").Value)   ' 0 = AUTO

            Dim keyRow As Long
            keyRow = 0
            If IsNumeric(wsCfg.Cells(r, "I").Value) Then keyRow = CLng(wsCfg.Cells(r, "I").Value)

            If SheetExists(wbTemplate, templateSheetName) And SheetExists(wbChild, childSheetName) Then
                SyncOneSheetBlock _
                    wbTemplate.Worksheets(templateSheetName), _
                    wbChild.Worksheets(childSheetName), _
                    headerTop, headerBottom, dataStart, _
                    firstCol, lastCol, keyRow, wbTemplate
            End If
        End If
    Next r
End Sub

Private Function SheetExists(ByVal wb As Workbook, ByVal sheetName As String) As Boolean
    On Error Resume Next
    SheetExists = Not wb.Worksheets(sheetName) Is Nothing
    On Error GoTo 0
End Function


'========================================================================================
'   5) SINCRONIZAR 1 HOJA (1 BLOQUE / TABLA)
'========================================================================================
Private Sub SyncOneSheetBlock( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal dataStart As Long, _
    ByVal firstCol As Long, ByVal lastCol As Long, _
    ByVal keyRow As Long, _
    ByVal wbTemplate As Workbook)

    ' Detectar bloque real si firstCol/lastCol vienen a 0
    If firstCol = 0 Then firstCol = FirstNonEmptyCol(wsT, headerTop, headerBottom)
    If lastCol = 0 Then lastCol = LastNonEmptyCol(wsT, headerTop, headerBottom)
    If firstCol = 0 Or lastCol = 0 Or lastCol < firstCol Then Exit Sub

    ' Última fila con datos en plantilla dentro de este bloque
    Dim lastRowT As Long
    lastRowT = LastUsedRowInColumns(wsT, firstCol, lastCol)
    If lastRowT < dataStart Then lastRowT = dataStart

    ' Claves de columnas (para alinear)
    Dim keysT As Variant, keysC As Variant
    keysT = GetColumnKeys(wsT, headerTop, headerBottom, firstCol, lastCol, keyRow)
    keysC = GetColumnKeys(wsC, headerTop, headerBottom, firstCol, LastNonEmptyCol(wsC, headerTop, headerBottom), keyRow)

    ' Insertar columnas que falten / renombres / eliminar extras
    AlignChildColumnsToTemplate wsT, wsC, keysT, keysC, headerTop, headerBottom, dataStart, lastRowT, firstCol, lastCol, keyRow, wbTemplate

    ' Refrescar formatos de cabecera SOLO si no hay KEY_ROW
    If REFRESH_HEADER_FORMATS Then
        If keyRow = 0 Then
            CopyHeaderFormats wsT, wsC, headerTop, headerBottom, firstCol, LastNonEmptyCol(wsC, headerTop, headerBottom)
        End If
    End If

    ' Limpieza de referencias externas
    If FIX_EXTERNAL_REFS_WHOLE_SHEET Then
        FixTemplateWorkbookRefsInRange wsC.UsedRange, wbTemplate
    End If
End Sub


'========================================================================================
'   6) ALINEADO DE COLUMNAS + RENOMBRE CABECERAS
'========================================================================================
Private Sub AlignChildColumnsToTemplate( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal keysT As Variant, ByVal keysC As Variant, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal dataStart As Long, ByVal lastRowT As Long, _
    ByVal firstCol As Long, ByVal lastColT As Long, _
    ByVal keyRow As Long, _
    ByVal wbTemplate As Workbook)

    ' Diccionario de columnas del hijo: key -> columna real en hoja
    Dim dictC As Object: Set dictC = CreateObject("Scripting.Dictionary")

    Dim idxC As Long
    For idxC = LBound(keysC) To UBound(keysC)
        If Len(keysC(idxC)) > 0 Then
            dictC(keysC(idxC)) = firstCol + (idxC - LBound(keysC))
        End If
    Next idxC

    ' Diccionario de keys del template (para detectar renombres)
    Dim dictT As Object: Set dictT = CreateObject("Scripting.Dictionary")
    Dim it As Long
    For it = LBound(keysT) To UBound(keysT)
        If Len(keysT(it)) > 0 Then dictT(keysT(it)) = True
    Next it

    Dim i As Long
    For i = LBound(keysT) To UBound(keysT)

        Dim key As String
        key = keysT(i)

        Dim targetColInChild As Long
        targetColInChild = firstCol + (i - LBound(keysT))

        If Len(key) = 0 Then
            ' nada
        Else
            If dictC.Exists(key) Then
                ' La columna ya existe en el hijo
            Else
                ' 1) Intentar tratarlo como "renombre":
                '    - Si en esa posición existe una cabecera distinta que no está en template,
                '      actualiza SOLO cabecera (conserva datos).
                If HANDLE_HEADER_RENAMES Then
                    If ShouldTreatAsRename(wsT, wsC, targetColInChild, headerTop, headerBottom, keyRow, dictT) Then

                        Dim oldKey As String
                        oldKey = BuildHeaderKeySmart(wsC, targetColInChild, headerTop, headerBottom, keyRow)

                        On Error Resume Next
                        If Len(oldKey) > 0 Then dictC.Remove oldKey
                        On Error GoTo 0

                        CopyTemplateHeaderOnlyToChildColumn wsT, wsC, _
                            templateCol:=targetColInChild, childCol:=targetColInChild, _
                            headerTop:=headerTop, headerBottom:=headerBottom, _
                            wbTemplate:=wbTemplate

                        dictC(key) = targetColInChild
                        GoTo NextI
                    End If
                End If

                ' 2) Columna nueva real: insertar + copiar cabecera y datos (plantilla)
                wsC.Columns(targetColInChild).Insert Shift:=xlToRight
                ShiftDictRight dictC, targetColInChild

                CopyNewTemplateColumn wsT, wsC, _
                    templateCol:=targetColInChild, childCol:=targetColInChild, _
                    headerTop:=headerTop, headerBottom:=headerBottom, _
                    dataStart:=dataStart, lastRowT:=lastRowT, _
                    wbTemplate:=wbTemplate

                dictC(key) = targetColInChild
            End If
        End If

NextI:
    Next i

    ' Borrar columnas "extra" del hijo
    If DELETE_EXTRA_COLUMNS Then
        DeleteExtraChildColumns wsT, wsC, headerTop, headerBottom, firstCol, lastColT, keyRow
    End If
End Sub

Private Sub ShiftDictRight(ByVal dictC As Object, ByVal fromCol As Long)
    Dim k As Variant
    For Each k In dictC.Keys
        If dictC(k) >= fromCol Then dictC(k) = dictC(k) + 1
    Next k
End Sub

Private Sub DeleteExtraChildColumns( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal firstCol As Long, ByVal lastColT As Long, _
    ByVal keyRow As Long)

    Dim lastColC As Long
    lastColC = LastNonEmptyCol(wsC, headerTop, headerBottom)
    If lastColC < firstCol Then Exit Sub

    Dim keysT As Object: Set keysT = CreateObject("Scripting.Dictionary")
    Dim c As Long

    For c = firstCol To lastColT
        Dim kt As String
        kt = BuildHeaderKeySmart(wsT, c, headerTop, headerBottom, keyRow)
        If Len(kt) > 0 Then keysT(kt) = True
    Next c

    For c = lastColC To firstCol Step -1
        Dim kc As String
        kc = BuildHeaderKeySmart(wsC, c, headerTop, headerBottom, keyRow)

        If Len(kc) > 0 Then
            If Not keysT.Exists(kc) Then
                wsC.Columns(c).Delete
            End If
        End If
    Next c
End Sub


'========================================================================================
'   7) COPIAR COLUMNA NUEVA (CABECERA + DATOS/FÓRMULAS DESDE PLANTILLA)
'========================================================================================
Private Sub CopyNewTemplateColumn( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal templateCol As Long, ByVal childCol As Long, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal dataStart As Long, ByVal lastRowT As Long, _
    ByVal wbTemplate As Workbook)

    wsC.Columns(childCol).ColumnWidth = wsT.Columns(templateCol).ColumnWidth

    ' Cabeceras
    wsT.Range(wsT.Cells(headerTop, templateCol), wsT.Cells(headerBottom, templateCol)).Copy
    wsC.Cells(headerTop, childCol).PasteSpecial Paste:=xlPasteAll

    ' Datos / fórmulas
    wsT.Range(wsT.Cells(dataStart, templateCol), wsT.Cells(lastRowT, templateCol)).Copy
    wsC.Cells(dataStart, childCol).PasteSpecial Paste:=xlPasteAll

    Application.CutCopyMode = False

    ' Limpiar referencias externas en lo pegado
    FixTemplateWorkbookRefsInRange wsC.Range(wsC.Cells(headerTop, childCol), wsC.Cells(headerBottom, childCol)), wbTemplate
    FixTemplateWorkbookRefsInRange wsC.Range(wsC.Cells(dataStart, childCol), wsC.Cells(lastRowT, childCol)), wbTemplate
End Sub

Private Sub CopyHeaderFormats( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal firstCol As Long, ByVal lastCol As Long)

    wsT.Range(wsT.Cells(headerTop, firstCol), wsT.Cells(headerBottom, lastCol)).Copy
    wsC.Range(wsC.Cells(headerTop, firstCol), wsC.Cells(headerBottom, lastCol)).PasteSpecial Paste:=xlPasteFormats
    Application.CutCopyMode = False
End Sub


'========================================================================================
'   8) RENOMBRE CABECERAS (COPIAR SOLO CABECERA, CONSERVAR DATOS)
'========================================================================================
Private Function ShouldTreatAsRename( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal targetColInChild As Long, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal keyRow As Long, _
    ByVal templateKeys As Object) As Boolean

    If targetColInChild <= 0 Then Exit Function

    Dim childKey As String
    childKey = BuildHeaderKeySmart(wsC, targetColInChild, headerTop, headerBottom, keyRow)
    If Len(childKey) = 0 Then Exit Function

    ' Si el hijo tiene una cabecera que NO existe en plantilla, suele ser renombre
    If Not templateKeys.Exists(childKey) Then
        ShouldTreatAsRename = True
    End If
End Function

Private Sub CopyTemplateHeaderOnlyToChildColumn( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal templateCol As Long, ByVal childCol As Long, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal wbTemplate As Workbook)

    wsT.Range(wsT.Cells(headerTop, templateCol), wsT.Cells(headerBottom, templateCol)).Copy
    wsC.Cells(headerTop, childCol).PasteSpecial Paste:=xlPasteAll
    Application.CutCopyMode = False

    FixTemplateWorkbookRefsInRange wsC.Range(wsC.Cells(headerTop, childCol), wsC.Cells(headerBottom, childCol)), wbTemplate
End Sub


'========================================================================================
'   9) FIX: QUITAR REFERENCIAS AL LIBRO PLANTILLA EN FÓRMULAS
'========================================================================================
Private Sub FixTemplateWorkbookRefsInRange(ByVal rng As Range, ByVal wbTemplate As Workbook)
    On Error GoTo EH

    Dim tmplName As String
    tmplName = wbTemplate.Name

    Dim c As Range
    Dim f As String

    For Each c In rng.Cells
        If c.HasFormula Then
            f = c.Formula
            If InStr(1, f, "[", vbTextCompare) > 0 And InStr(1, f, "]", vbTextCompare) > 0 Then
                f = StripTemplateQualifierFromFormula(f, tmplName)
                c.Formula = f
            End If
        End If
    Next c

    Exit Sub
EH:
    ' no tumba el proceso
End Sub

Private Function StripTemplateQualifierFromFormula(ByVal formulaText As String, ByVal templateWbName As String) As String
    Dim s As String: s = formulaText
    Dim iOpen As Long, iClose As Long
    Dim inside As String

    iOpen = InStr(1, s, "[", vbTextCompare)

    Do While iOpen > 0
        iClose = InStr(iOpen + 1, s, "]", vbTextCompare)
        If iClose = 0 Then Exit Do

        inside = Mid$(s, iOpen + 1, iClose - iOpen - 1)

        If InStr(1, inside, templateWbName, vbTextCompare) > 0 Then
            s = Left$(s, iOpen - 1) & Mid$(s, iClose + 1)
            iOpen = InStr(1, s, "[", vbTextCompare)
        Else
            iOpen = InStr(iClose + 1, s, "[", vbTextCompare)
        End If
    Loop

    StripTemplateQualifierFromFormula = s
End Function


'========================================================================================
'   10) CLAVES DE COLUMNAS (multi-fila + merges) + KEY_ROW
'========================================================================================
Private Function GetColumnKeys( _
    ByVal ws As Worksheet, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal firstCol As Long, ByVal lastCol As Long, _
    ByVal keyRow As Long) As Variant

    Dim arr() As String
    Dim n As Long
    n = (lastCol - firstCol + 1)
    ReDim arr(1 To n)

    Dim c As Long, idx As Long
    idx = 1
    For c = firstCol To lastCol
        arr(idx) = BuildHeaderKeySmart(ws, c, headerTop, headerBottom, keyRow)
        idx = idx + 1
    Next c

    GetColumnKeys = arr
End Function

Private Function BuildHeaderKeySmart( _
    ByVal ws As Worksheet, _
    ByVal col As Long, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal keyRow As Long) As String

    ' Si hay KEY_ROW, intentamos usar ese valor (p.ej. 1..40) como clave principal
    If keyRow >= headerTop And keyRow <= headerBottom And keyRow > 0 Then
        Dim vKR As String
        vKR = NormalizeHeaderText(GetMergedValue(ws.Cells(keyRow, col)))

        If Len(vKR) > 0 Then
            If IsNumeric(vKR) Then
                BuildHeaderKeySmart = "KR#" & CLng(Val(vKR))
            Else
                BuildHeaderKeySmart = "KR:" & vKR
            End If
            Exit Function
        End If
    End If

    ' Si no hay KEY_ROW o está vacío, usamos la firma multi-fila
    BuildHeaderKeySmart = BuildHeaderKeyFull(ws, col, headerTop, headerBottom)
End Function

Private Function BuildHeaderKeyFull( _
    ByVal ws As Worksheet, _
    ByVal col As Long, _
    ByVal headerTop As Long, ByVal headerBottom As Long) As String

    Dim parts As Collection
    Set parts = New Collection

    Dim r As Long
    For r = headerTop To headerBottom
        Dim v As String
        v = NormalizeHeaderText(GetMergedValue(ws.Cells(r, col)))

        If Len(v) > 0 Then
            If parts.Count = 0 Then
                parts.Add v
            Else
                If parts(parts.Count) <> v Then parts.Add v
            End If
        End If
    Next r

    Dim key As String
    key = ""

    Dim i As Long
    For i = 1 To parts.Count
        If Len(key) = 0 Then
            key = parts(i)
        Else
            key = key & "|" & parts(i)
        End If
    Next i

    BuildHeaderKeyFull = key
End Function

Private Function NormalizeHeaderText(ByVal s As String) As String
    Dim t As String
    t = CStr(s)
    t = Replace(t, vbCr, " ")
    t = Replace(t, vbLf, " ")
    t = Application.Trim(t)
    NormalizeHeaderText = t
End Function

Private Function GetMergedValue(ByVal cell As Range) As String
    On Error GoTo EH

    Dim v As Variant
    If cell.MergeCells Then
        v = cell.MergeArea.Cells(1, 1).Value
    Else
        v = cell.Value
    End If

    If IsError(v) Then
        GetMergedValue = ""
    Else
        GetMergedValue = CStr(v)
    End If
    Exit Function

EH:
    GetMergedValue = ""
End Function


'========================================================================================
'   11) AUTO-DETECCIÓN DE PRIMERA / ÚLTIMA COLUMNA REAL (en cabeceras)
'========================================================================================
Private Function FirstNonEmptyCol(ByVal ws As Worksheet, ByVal r1 As Long, ByVal r2 As Long) As Long
    Dim minCol As Long: minCol = 0
    Dim r As Long

    For r = r1 To r2
        Dim f As Range
        Set f = ws.Rows(r).Find(What:="*", LookIn:=xlFormulas, LookAt:=xlPart, _
                                SearchOrder:=xlByColumns, SearchDirection:=xlNext)
        If Not f Is Nothing Then
            If minCol = 0 Or f.Column < minCol Then minCol = f.Column
        End If
    Next r

    FirstNonEmptyCol = minCol
End Function

Private Function LastNonEmptyCol(ByVal ws As Worksheet, ByVal r1 As Long, ByVal r2 As Long) As Long
    Dim maxCol As Long: maxCol = 0
    Dim r As Long

    For r = r1 To r2
        Dim f As Range
        Set f = ws.Rows(r).Find(What:="*", LookIn:=xlFormulas, LookAt:=xlPart, _
                                SearchOrder:=xlByColumns, SearchDirection:=xlPrevious)
        If Not f Is Nothing Then
            If f.Column > maxCol Then maxCol = f.Column
        End If
    Next r

    LastNonEmptyCol = maxCol
End Function

Private Function LastUsedRowInColumns(ByVal ws As Worksheet, ByVal c1 As Long, ByVal c2 As Long) As Long
    Dim rng As Range
    Set rng = ws.Range(ws.Cells(1, c1), ws.Cells(ws.Rows.Count, c2))

    Dim f As Range
    Set f = rng.Find(What:="*", LookIn:=xlFormulas, LookAt:=xlPart, _
                     SearchOrder:=xlByRows, SearchDirection:=xlPrevious)

    If f Is Nothing Then
        LastUsedRowInColumns = 0
    Else
        LastUsedRowInColumns = f.Row
    End If
End Function
