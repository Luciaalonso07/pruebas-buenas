Option Explicit

'========================================================================================
'   SINCRONIZADOR DE PLANTILLA -> EXCELS HIJOS (subcarpetas)
'
'   ACTUALIZACIÓN IMPORTANTE (KEY_ROW):
'   - Añade en CFG_SYNC la columna I: KEY_ROW
'   - Si KEY_ROW está informado (y cae entre HEADER_TOP..HEADER_BOTTOM),
'     la "firma" de columnas se construye usando esa fila (ideal si contiene 1..40, etc.)
'   - Si KEY_ROW está vacío/0, se usa el método original multi-fila (HEADER_TOP..HEADER_BOTTOM)
'
'   FIX IMPORTANTE (REFERENCIAS A PLANTILLA EN FÓRMULAS):
'   - Al copiar columnas desde la plantilla, Excel puede dejar fórmulas así:
'       =IF([Plantilla.xlsm]Valores!$BK6>2;"N/A";"")
'       =IF('[C:\...\Plantilla.xlsm]Valores'!$BK6>2;"N/A";"")
'   - Este módulo limpia esas referencias para que en el hijo queden:
'       =IF(Valores!$BK6>2;"N/A";"")
'========================================================================================

'=============================
'   AJUSTES PRINCIPALES
'=============================

Private Const CFG_SHEET_NAME As String = "CFG_SYNC"
Private Const CHILD_EXTENSIONS As String = "*.xlsx;*.xlsm;*.xlsb;*.xls"
Private Const TEMPLATE_FOLDER_NAME As String = "Plantilla"
Private Const DELETE_EXTRA_COLUMNS As Boolean = True
Private Const REFRESH_HEADER_FORMATS As Boolean = True

' Si quieres limpiar fórmulas de TODA la hoja (no solo de la columna nueva), deja True
Private Const FIX_EXTERNAL_REFS_WHOLE_SHEET As Boolean = True

'=============================
'   PUNTO DE ENTRADA
'=============================

Public Sub SYNC_Run()
    Dim rootFolder As String
    rootFolder = GetRootFolder()

    If Len(rootFolder) = 0 Then
        MsgBox "No se pudo calcular la carpeta raíz. Revisa la ruta de la plantilla.", vbExclamation
        Exit Sub
    End If

    Application.ScreenUpdating = False
    Application.DisplayAlerts = False
    Application.EnableEvents = False

    Dim oldCalc As XlCalculation
    oldCalc = Application.Calculation
    Application.Calculation = xlCalculationManual

    On Error GoTo CleanFail

    SyncAllChildrenInFolders rootFolder

CleanExit:
    Application.CutCopyMode = False
    Application.Calculation = oldCalc
    Application.EnableEvents = True
    Application.DisplayAlerts = True
    Application.ScreenUpdating = True
    MsgBox "SYNC terminado.", vbInformation
    Exit Sub

CleanFail:
    MsgBox "Error en SYNC: " & Err.Description, vbCritical
    Resume CleanExit
End Sub


'========================================================================================
'   1) RUTAS Y BÚSQUEDA DE ARCHIVOS HIJO
'========================================================================================

Private Function GetRootFolder() As String
    GetRootFolder = "C:\Users\VW356HB\OneDrive - EY\Desktop\pruebas buenas"
End Function

Private Function ParentFolder(ByVal folderPath As String) As String
    Dim p As Long
    p = InStrRev(folderPath, Application.PathSeparator)
    If p <= 1 Then
        ParentFolder = ""
    Else
        ParentFolder = Left(folderPath, p - 1)
    End If
End Function

Private Function CHILD_FOLDERS() As Variant
    CHILD_FOLDERS = Array("01.Prueba", "02.Prueba")
End Function

Private Sub SyncAllChildrenInFolders(ByVal rootFolder As String)
    Dim fso As Object: Set fso = CreateObject("Scripting.FileSystemObject")

    Dim folders As Variant
    folders = CHILD_FOLDERS()

    Dim i As Long
    For i = LBound(folders) To UBound(folders)
        Dim childFolder As String
        childFolder = rootFolder & Application.PathSeparator & CStr(folders(i))

        If fso.FolderExists(childFolder) Then
            SyncAllChildrenInOneFolder childFolder
        End If
    Next i
End Sub

Private Sub SyncAllChildrenInOneFolder(ByVal folderPath As String)
    Dim patterns As Variant
    patterns = Split(CHILD_EXTENSIONS, ";")

    Dim p As Long
    For p = LBound(patterns) To UBound(patterns)
        Dim fileName As String
        fileName = Dir(folderPath & Application.PathSeparator & patterns(p))

        Do While Len(fileName) > 0
            If LCase(fileName) <> LCase(ThisWorkbook.Name) Then
                SyncOneChildWorkbook folderPath & Application.PathSeparator & fileName
            End If
            fileName = Dir
        Loop
    Next p
End Sub


'========================================================================================
'   2) SINCRONIZAR 1 ARCHIVO HIJO
'========================================================================================

Private Sub SyncOneChildWorkbook(ByVal childFullPath As String)
    Dim wbChild As Workbook
    Set wbChild = Workbooks.Open(childFullPath, ReadOnly:=False)

    On Error GoTo SafeClose

    SyncWorkbookFromTemplate ThisWorkbook, wbChild

    wbChild.Close SaveChanges:=True
    Exit Sub

SafeClose:
    On Error Resume Next
    wbChild.Close SaveChanges:=False
End Sub

Private Sub SyncWorkbookFromTemplate(ByVal wbTemplate As Workbook, ByVal wbChild As Workbook)
    Dim wsCfg As Worksheet
    Set wsCfg = wbTemplate.Worksheets(CFG_SHEET_NAME)

    Dim lastRow As Long
    lastRow = wsCfg.Cells(wsCfg.Rows.Count, "A").End(xlUp).Row

    Dim r As Long
    For r = 2 To lastRow
        Dim activeFlag As String
        activeFlag = Trim$(CStr(wsCfg.Cells(r, "A").Value))

        If UCase$(activeFlag) = "Y" Then
            Dim templateSheetName As String
            templateSheetName = CStr(wsCfg.Cells(r, "B").Value)

            Dim childSheetName As String
            childSheetName = CStr(wsCfg.Cells(r, "C").Value)
            If Len(Trim$(childSheetName)) = 0 Then childSheetName = templateSheetName

            Dim headerTop As Long, headerBottom As Long, dataStart As Long
            headerTop = CLng(wsCfg.Cells(r, "D").Value)
            headerBottom = CLng(wsCfg.Cells(r, "E").Value)
            dataStart = CLng(wsCfg.Cells(r, "F").Value)

            Dim firstCol As Long, lastCol As Long
            firstCol = CLng(wsCfg.Cells(r, "G").Value)  '0 = AUTO
            lastCol = CLng(wsCfg.Cells(r, "H").Value)   '0 = AUTO

            ' NUEVO: KEY_ROW (columna I)
            Dim keyRow As Long
            keyRow = 0
            If IsNumeric(wsCfg.Cells(r, "I").Value) Then keyRow = CLng(wsCfg.Cells(r, "I").Value)

            If SheetExists(wbTemplate, templateSheetName) And SheetExists(wbChild, childSheetName) Then
                SyncOneSheetBlock _
                    wbTemplate.Worksheets(templateSheetName), _
                    wbChild.Worksheets(childSheetName), _
                    headerTop, headerBottom, dataStart, firstCol, lastCol, keyRow, wbTemplate
            End If
        End If
    Next r
End Sub

Private Function SheetExists(ByVal wb As Workbook, ByVal sheetName As String) As Boolean
    On Error Resume Next
    SheetExists = Not wb.Worksheets(sheetName) Is Nothing
    On Error GoTo 0
End Function


'========================================================================================
'   3) SINCRONIZAR 1 HOJA (1 BLOQUE / TABLA)
'========================================================================================

Private Sub SyncOneSheetBlock( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal dataStart As Long, _
    ByVal firstCol As Long, ByVal lastCol As Long, _
    ByVal keyRow As Long, _
    ByVal wbTemplate As Workbook)

    If firstCol = 0 Then firstCol = FirstNonEmptyCol(wsT, headerTop, headerBottom)
    If lastCol = 0 Then lastCol = LastNonEmptyCol(wsT, headerTop, headerBottom)
    If firstCol = 0 Or lastCol = 0 Or lastCol < firstCol Then Exit Sub

    Dim lastRowT As Long
    lastRowT = LastUsedRowInColumns(wsT, firstCol, lastCol)

    Dim lastRowC As Long
    lastRowC = LastUsedRowInColumns(wsC, firstCol, lastCol)

    If lastRowT < dataStart Then lastRowT = dataStart
    If lastRowC < dataStart Then lastRowC = dataStart

    Dim keysT As Variant, keysC As Variant
    keysT = GetColumnKeys(wsT, headerTop, headerBottom, firstCol, lastCol, keyRow)
    keysC = GetColumnKeys(wsC, headerTop, headerBottom, firstCol, LastNonEmptyCol(wsC, headerTop, headerBottom), keyRow)

    AlignChildColumnsToTemplate wsT, wsC, keysT, keysC, headerTop, headerBottom, dataStart, lastRowT, firstCol, lastCol, keyRow, wbTemplate

    If REFRESH_HEADER_FORMATS Then
        CopyHeaderFormats wsT, wsC, headerTop, headerBottom, firstCol, LastNonEmptyCol(wsC, headerTop, headerBottom)
    End If

    ' Limpieza global de referencias a Plantilla (por si ya existían fórmulas con [Plantilla.xlsm]...)
    If FIX_EXTERNAL_REFS_WHOLE_SHEET Then
        FixTemplateWorkbookRefsInRange wsC.UsedRange, wbTemplate
    End If
End Sub


'========================================================================================
'   4) LÓGICA DE ALINEADO (INSERTAR / ELIMINAR)
'========================================================================================

Private Sub AlignChildColumnsToTemplate( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal keysT As Variant, ByVal keysC As Variant, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal dataStart As Long, ByVal lastRowT As Long, _
    ByVal firstCol As Long, ByVal lastColT As Long, _
    ByVal keyRow As Long, _
    ByVal wbTemplate As Workbook)

    Dim dictC As Object: Set dictC = CreateObject("Scripting.Dictionary")
    Dim colIndexC As Long

    For colIndexC = LBound(keysC) To UBound(keysC)
        If Len(keysC(colIndexC)) > 0 Then
            dictC(keysC(colIndexC)) = firstCol + (colIndexC - LBound(keysC))
        End If
    Next colIndexC

    Dim i As Long
    Dim currentChildLastCol As Long
    currentChildLastCol = LastNonEmptyCol(wsC, headerTop, headerBottom)
    If currentChildLastCol < firstCol Then currentChildLastCol = firstCol

    For i = LBound(keysT) To UBound(keysT)
        Dim key As String
        key = keysT(i)

        Dim targetColInChild As Long
        targetColInChild = firstCol + (i - LBound(keysT))

        If Len(key) = 0 Then
            ' saltamos
        Else
            If dictC.Exists(key) Then
                ' existe
            Else
                wsC.Columns(targetColInChild).Insert Shift:=xlToRight
                ShiftDictRight dictC, targetColInChild

                CopyNewTemplateColumn wsT, wsC, _
                    templateCol:=targetColInChild, childCol:=targetColInChild, _
                    headerTop:=headerTop, headerBottom:=headerBottom, _
                    dataStart:=dataStart, lastRowT:=lastRowT, _
                    wbTemplate:=wbTemplate

                dictC(key) = targetColInChild
                currentChildLastCol = currentChildLastCol + 1
            End If
        End If
    Next i

    If DELETE_EXTRA_COLUMNS Then
        DeleteExtraChildColumns wsT, wsC, headerTop, headerBottom, firstCol, lastColT, keyRow
    End If
End Sub

Private Sub ShiftDictRight(ByVal dictC As Object, ByVal fromCol As Long)
    Dim k As Variant
    For Each k In dictC.Keys
        If dictC(k) >= fromCol Then dictC(k) = dictC(k) + 1
    Next k
End Sub

Private Sub DeleteExtraChildColumns( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal firstCol As Long, ByVal lastColT As Long, _
    ByVal keyRow As Long)

    Dim lastColC As Long
    lastColC = LastNonEmptyCol(wsC, headerTop, headerBottom)
    If lastColC < firstCol Then Exit Sub

    Dim keysT As Object: Set keysT = CreateObject("Scripting.Dictionary")
    Dim c As Long

    For c = firstCol To lastColT
        Dim kt As String
        kt = BuildHeaderKeySmart(wsT, c, headerTop, headerBottom, keyRow)
        If Len(kt) > 0 Then keysT(kt) = True
    Next c

    For c = lastColC To firstCol Step -1
        Dim kc As String
        kc = BuildHeaderKeySmart(wsC, c, headerTop, headerBottom, keyRow)

        If Len(kc) > 0 Then
            If Not keysT.Exists(kc) Then
                wsC.Columns(c).Delete
            End If
        End If
    Next c
End Sub


'========================================================================================
'   5) COPIAR COLUMNA NUEVA DESDE PLANTILLA
'========================================================================================

Private Sub CopyNewTemplateColumn( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal templateCol As Long, ByVal childCol As Long, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal dataStart As Long, ByVal lastRowT As Long, _
    ByVal wbTemplate As Workbook)

    wsC.Columns(childCol).ColumnWidth = wsT.Columns(templateCol).ColumnWidth

    ' Cabeceras
    wsT.Range(wsT.Cells(headerTop, templateCol), wsT.Cells(headerBottom, templateCol)).Copy
    wsC.Cells(headerTop, childCol).PasteSpecial Paste:=xlPasteAll

    ' Datos / fórmulas (hasta lastRowT en plantilla)
    wsT.Range(wsT.Cells(dataStart, templateCol), wsT.Cells(lastRowT, templateCol)).Copy
    wsC.Cells(dataStart, childCol).PasteSpecial Paste:=xlPasteAll

    Application.CutCopyMode = False

    ' CLAVE: quitar [Plantilla.xlsm] / ['C:\...\Plantilla.xlsm'] de fórmulas pegadas
    FixTemplateWorkbookRefsInRange wsC.Range(wsC.Cells(headerTop, childCol), wsC.Cells(headerBottom, childCol)), wbTemplate
    FixTemplateWorkbookRefsInRange wsC.Range(wsC.Cells(dataStart, childCol), wsC.Cells(lastRowT, childCol)), wbTemplate
End Sub

Private Sub CopyHeaderFormats( _
    ByVal wsT As Worksheet, ByVal wsC As Worksheet, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal firstCol As Long, ByVal lastCol As Long)

    wsT.Range(wsT.Cells(headerTop, firstCol), wsT.Cells(headerBottom, lastCol)).Copy
    wsC.Range(wsC.Cells(headerTop, firstCol), wsC.Cells(headerBottom, lastCol)).PasteSpecial Paste:=xlPasteFormats
    Application.CutCopyMode = False
End Sub


'========================================================================================
'   5B) FIX: QUITAR REFERENCIAS AL LIBRO PLANTILLA EN FÓRMULAS
'       Maneja:
'         [Plantilla.xlsm]Valores!A1
'         '[Plantilla.xlsm]Valores'!A1
'         '[C:\...\Plantilla.xlsm]Valores'!A1
'========================================================================================

Private Sub FixTemplateWorkbookRefsInRange(ByVal rng As Range, ByVal wbTemplate As Workbook)
    On Error GoTo EH

    Dim tmplName As String
    tmplName = wbTemplate.Name

    Dim c As Range
    Dim f As String

    For Each c In rng.Cells
        If c.HasFormula Then
            f = c.Formula
            If InStr(1, f, "[", vbTextCompare) > 0 And InStr(1, f, "]", vbTextCompare) > 0 Then
                f = StripTemplateQualifierFromFormula(f, tmplName)
                c.Formula = f
            End If
        End If
    Next c

    Exit Sub
EH:
    ' si alguna celda da error, no tumba el proceso
End Sub

' Quita cualquier parte entre corchetes [...] si dentro aparece el nombre de la plantilla
Private Function StripTemplateQualifierFromFormula(ByVal formulaText As String, ByVal templateWbName As String) As String
    Dim s As String: s = formulaText
    Dim iOpen As Long, iClose As Long
    Dim inside As String

    iOpen = InStr(1, s, "[", vbTextCompare)

    Do While iOpen > 0
        iClose = InStr(iOpen + 1, s, "]", vbTextCompare)
        If iClose = 0 Then Exit Do

        inside = Mid$(s, iOpen + 1, iClose - iOpen - 1) ' lo que hay entre [ ... ]

        ' Si dentro aparece "Plantilla.xlsm" (aunque haya ruta), lo quitamos
        If InStr(1, inside, templateWbName, vbTextCompare) > 0 Then
            s = Left$(s, iOpen - 1) & Mid$(s, iClose + 1)
            ' seguimos buscando desde el principio (por si hay varias refs)
            iOpen = InStr(1, s, "[", vbTextCompare)
        Else
            iOpen = InStr(iClose + 1, s, "[", vbTextCompare)
        End If
    Loop

    StripTemplateQualifierFromFormula = s
End Function


'========================================================================================
'   6) OBTENER CLAVES DE COLUMNAS (multi-fila + merges) + KEY_ROW
'========================================================================================

Private Function GetColumnKeys( _
    ByVal ws As Worksheet, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal firstCol As Long, ByVal lastCol As Long, _
    ByVal keyRow As Long) As Variant

    Dim arr() As String
    Dim n As Long
    n = (lastCol - firstCol + 1)
    ReDim arr(1 To n)

    Dim c As Long, idx As Long
    idx = 1
    For c = firstCol To lastCol
        arr(idx) = BuildHeaderKeySmart(ws, c, headerTop, headerBottom, keyRow)
        idx = idx + 1
    Next c

    GetColumnKeys = arr
End Function

Private Function BuildHeaderKeySmart( _
    ByVal ws As Worksheet, _
    ByVal col As Long, _
    ByVal headerTop As Long, ByVal headerBottom As Long, _
    ByVal keyRow As Long) As String

    If keyRow >= headerTop And keyRow <= headerBottom And keyRow > 0 Then
        Dim vKR As String
        vKR = NormalizeHeaderText(GetMergedValue(ws.Cells(keyRow, col)))

        If Len(vKR) > 0 Then
            If IsNumeric(vKR) Then
                BuildHeaderKeySmart = "KR#" & CLng(Val(vKR))
            Else
                BuildHeaderKeySmart = "KR:" & vKR
            End If
            Exit Function
        End If
    End If

    BuildHeaderKeySmart = BuildHeaderKeyFull(ws, col, headerTop, headerBottom)
End Function

Private Function BuildHeaderKeyFull( _
    ByVal ws As Worksheet, _
    ByVal col As Long, _
    ByVal headerTop As Long, ByVal headerBottom As Long) As String

    Dim parts As Collection
    Set parts = New Collection

    Dim r As Long
    For r = headerTop To headerBottom
        Dim v As String
        v = NormalizeHeaderText(GetMergedValue(ws.Cells(r, col)))

        If Len(v) > 0 Then
            If parts.Count = 0 Then
                parts.Add v
            Else
                If parts(parts.Count) <> v Then parts.Add v
            End If
        End If
    Next r

    Dim key As String
    key = ""
    Dim i As Long
    For i = 1 To parts.Count
        If Len(key) = 0 Then
            key = parts(i)
        Else
            key = key & "|" & parts(i)
        End If
    Next i

    BuildHeaderKeyFull = key
End Function

Private Function NormalizeHeaderText(ByVal s As String) As String
    Dim t As String
    t = CStr(s)
    t = Replace(t, vbCr, " ")
    t = Replace(t, vbLf, " ")
    t = Application.Trim(t)
    NormalizeHeaderText = t
End Function

Private Function GetMergedValue(ByVal cell As Range) As String
    On Error GoTo EH

    Dim v As Variant
    If cell.MergeCells Then
        v = cell.MergeArea.Cells(1, 1).Value
    Else
        v = cell.Value
    End If

    If IsError(v) Then
        GetMergedValue = ""
    Else
        GetMergedValue = CStr(v)
    End If
    Exit Function

EH:
    GetMergedValue = ""
End Function


'========================================================================================
'   7) AUTO-DETECCIÓN DE PRIMERA / ÚLTIMA COLUMNA REAL (en cabeceras)
'========================================================================================

Private Function FirstNonEmptyCol(ByVal ws As Worksheet, ByVal r1 As Long, ByVal r2 As Long) As Long
    Dim minCol As Long: minCol = 0
    Dim r As Long

    For r = r1 To r2
        Dim f As Range
        Set f = ws.Rows(r).Find(What:="*", LookIn:=xlFormulas, LookAt:=xlPart, _
                                SearchOrder:=xlByColumns, SearchDirection:=xlNext)
        If Not f Is Nothing Then
            If minCol = 0 Or f.Column < minCol Then minCol = f.Column
        End If
    Next r

    FirstNonEmptyCol = minCol
End Function

Private Function LastNonEmptyCol(ByVal ws As Worksheet, ByVal r1 As Long, ByVal r2 As Long) As Long
    Dim maxCol As Long: maxCol = 0
    Dim r As Long

    For r = r1 To r2
        Dim f As Range
        Set f = ws.Rows(r).Find(What:="*", LookIn:=xlFormulas, LookAt:=xlPart, _
                                SearchOrder:=xlByColumns, SearchDirection:=xlPrevious)
        If Not f Is Nothing Then
            If f.Column > maxCol Then maxCol = f.Column
        End If
    Next r

    LastNonEmptyCol = maxCol
End Function

Private Function LastUsedRowInColumns(ByVal ws As Worksheet, ByVal c1 As Long, ByVal c2 As Long) As Long
    Dim rng As Range
    Set rng = ws.Range(ws.Cells(1, c1), ws.Cells(ws.Rows.Count, c2))

    Dim f As Range
    Set f = rng.Find(What:="*", LookIn:=xlFormulas, LookAt:=xlPart, _
                     SearchOrder:=xlByRows, SearchDirection:=xlPrevious)
    If f Is Nothing Then
        LastUsedRowInColumns = 0
    Else
        LastUsedRowInColumns = f.Row
    End If
End Function
